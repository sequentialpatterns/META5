package com.webdevils{	import flash.display.*;	import flash.events.*;	import flash.net.*;	import caurina.transitions.Tweener;	public class Load_Content extends EventDispatcher {		public static const START:String = "start";				public var current_content:DisplayObject;		private var host_mc;		private var old_content:Array;		private var open_tween:Object;// Object to hold the tween that introduce a new clip		private var exit_tween:Object;// Object to hold tween that exits a clip		private var starting_values:Object;		public function Load_Content( _mc, o_tween:Object, c_tween:Object, start_obj:Object ) {			host_mc = _mc;			old_content = new Array  ;			open_tween = o_tween;			exit_tween = c_tween;			exit_tween.onComplete=remove_content;// Make sure to add the onComplete call to remove_content			starting_values=start_obj;		}		public function set_open_tween(_obj:Object):void {			open_tween=_obj;		}		public function set_close_tween(_obj:Object):void {			exit_tween=_obj;		}		public function set_start_obj(_obj:Object):void {			starting_values=_obj;		}		public function add_content( url:String = null ):void {			// Check for old content and move it off the stage			if ( current_content != null ) {				exit_tween.onCompleteParams = [ current_content ];				Tweener.addTween( current_content, exit_tween );			}			if ( url != null ) {				// Create a new loader and start loading				var loader = new Loader();				loader.contentLoaderInfo.addEventListener( Event.INIT, on_init );				loader.contentLoaderInfo.addEventListener( ProgressEvent.PROGRESS, on_progress );				loader.contentLoaderInfo.addEventListener( HTTPStatusEvent.HTTP_STATUS, on_http );				loader.contentLoaderInfo.addEventListener( Event.COMPLETE, on_complete );				loader.contentLoaderInfo.addEventListener( IOErrorEvent.IO_ERROR, on_ioerror );				loader.contentLoaderInfo.addEventListener( Event.OPEN, on_open );				loader.contentLoaderInfo.addEventListener( Event.UNLOAD, on_unload );				loader.load( new URLRequest( url ) );			}		}		/*******************************************************************************/		// Loader Event Handlers		private function on_unload(e:Event):void {			// trace("Un load");		}		private function on_open( e:Event ):void {			dispatchEvent( new Event( Event.OPEN ) );		}		private function on_ioerror(e:IOErrorEvent):void {			// trace(e.toString());		}		private function on_http(e:HTTPStatusEvent):void {			// trace("http status");		}		private function on_init(e:Event):void {			dispatchEvent( new Event( Event.INIT ) );		}		private function on_progress(e:ProgressEvent):void {			dispatchEvent( new ProgressEvent( ProgressEvent.PROGRESS, false, false, e.bytesLoaded, e.bytesTotal ) );		}		private function on_complete( e:Event ):void {			var loader = e.target;			current_content = loader.content;						for ( var p in starting_values ) {				current_content[p] = starting_values[p];			}			Tweener.addTween( current_content, open_tween );			host_mc.addChild( current_content );									/****************************************************************************************/			loader.removeEventListener( Event.INIT, on_init );			loader.removeEventListener( ProgressEvent.PROGRESS, on_progress );			loader.removeEventListener( HTTPStatusEvent.HTTP_STATUS,on_http );			loader.removeEventListener( Event.COMPLETE,on_complete);			loader.removeEventListener( IOErrorEvent.IO_ERROR,on_ioerror);			loader.removeEventListener( Event.OPEN, on_open );			loader.removeEventListener( Event.UNLOAD, on_unload );			/****************************************************************************************/						// delete loader;			dispatchEvent( new Event( Event.COMPLETE ) );		}		private function remove_content( _mc ):void {			if ( host_mc.getChildByName( _mc.name ) != null ) {				host_mc.removeChild( _mc );				if ( _mc is Bitmap ) {					( _mc as Bitmap ).bitmapData.dispose();				}			}		}	}}